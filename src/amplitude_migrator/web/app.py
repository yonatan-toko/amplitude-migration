import os
import json, socket
from pathlib import Path
from typing import Any, Dict
from fastapi import FastAPI, HTTPException, UploadFile, File, Body
from fastapi.middleware.cors import CORSMiddleware
from fastapi.staticfiles import StaticFiles
from fastapi.responses import FileResponse, JSONResponse
import uvicorn
from pydantic import BaseModel
from amplitude_migrator.runner import run_migration


# Where this file lives (inside the installed package)
BASE_DIR = Path(__file__).resolve().parent
STATIC_DIR = BASE_DIR / "static"

# Default initialized workspace (created by `amp-migrate init`)
DEFAULT_PROJECT_DIR = Path.cwd() / "amplitude_migration_project"
CONFIG_PATH = DEFAULT_PROJECT_DIR / "config.py"
SETTINGS_JSON = DEFAULT_PROJECT_DIR / "settings.json"  # reserved for future use

# Where migration run reports are written by the CLI/library.
# Global convention: use ./migration_runs (underscore). Users can override with MIGRATION_REPORTS_DIR.

def _get_reports_dir() -> Path:
    # 1) Explicit env var always wins
    env_dir = os.getenv("MIGRATION_REPORTS_DIR")
    if env_dir:
        return Path(env_dir).expanduser().resolve()

    # 2) If config.py exists and defines REPORTS_DIR that exists, prefer it
    try:
        if CONFIG_PATH.exists():
            ns: Dict[str, Any] = {}
            exec(CONFIG_PATH.read_text(encoding="utf-8"), {}, ns)
            cfg_dir = CONFIG_PATH.parent
            rep_val = ns.get("REPORTS_DIR")
            if rep_val:
                rep_path = (cfg_dir / str(rep_val)).expanduser().resolve() if not os.path.isabs(str(rep_val)) else Path(str(rep_val)).expanduser().resolve()
                if rep_path.exists():
                    return rep_path
    except Exception:
        pass  # fall through to conventional locations

    # 3) Conventional locations (do not create)
    underscore = Path("migration_runs").resolve()
    if underscore.exists():
        return underscore
    hyphen = Path("migration-runs").resolve()
    if hyphen.exists():
        return hyphen

    # 4) Default to canonical underscore path (may not exist yet)
    return underscore

REPORTS_DIR = _get_reports_dir()

app = FastAPI(title="Amplitude Migrator UI", version="1.0")

# Basic permissive CORS so people can run a frontend dev server if they want
app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"], allow_credentials=True,
    allow_methods=["*"], allow_headers=["*"],
)


# -------- Helpers --------
DEFAULT_SETTINGS: Dict[str, Any] = {
    "SOURCE_PROJECT_API_KEY": "",
    "SOURCE_REGION": "US",
    "LOCAL_EXPORT_GZ_PATH": "",
    "EXPORT_START": "",
    "EXPORT_END": "",
    "DEST_PROJECT_API_KEY": "",
    "DEST_REGION": "US",
    "EVENT_ALLOWLIST": [],
    "EVENT_PROPERTY_KEEP": {"*": ["*"]},
    "EVENT_RENAME_MAP": {},
    "EVENT_PROP_RENAME_MAP": {},
    "USER_ID_REMAP_PATH": "",
    "REMAP_SCOPE": "user_id",  # user_id | device_id | both
    "TIME_STRATEGY": "prefer_client_fallback_server_received",
    "ORIGINAL_TIMES_AS_PROPERTIES": True,
    "DRY_RUN": True,
    "REPORTS_DIR": "migration_runs",
    "REPORT_SAMPLE_LIMIT": 20,
    "VERBOSE": True,
}

def _read_config_py() -> Dict[str, Any]:
    if not CONFIG_PATH.exists():
        return DEFAULT_SETTINGS.copy()
    try:
        ns: Dict[str, Any] = {}
        exec(CONFIG_PATH.read_text(encoding="utf-8"), {}, ns)
        # only expose known keys, fall back to defaults
        out = DEFAULT_SETTINGS.copy()
        for k in list(DEFAULT_SETTINGS.keys()):
            if k in ns:
                out[k] = ns[k]
        return out
    except Exception:
        # If config is malformed, serve defaults to keep UI usable
        return DEFAULT_SETTINGS.copy()


def _render_config_py(settings: Dict[str, Any]) -> str:
    # Render a simple, well‑commented config.py from a settings dict
    lines = []
    lines.append("# Auto‑generated by Amplitude Migrator UI. Edit via the UI, or by hand if needed.\n")
    order = list(DEFAULT_SETTINGS.keys())
    for key in order:
        val = settings.get(key, DEFAULT_SETTINGS.get(key))
        # Ensure JSON‑serializable types render correctly in Python
        if isinstance(val, (dict, list, str, bool, int, float)) or val is None:
            py = repr(val)
        else:
            # last resort: string repr
            py = repr(str(val))
        lines.append(f"{key} = {py}")
    lines.append("")
    return "\n".join(lines)

@app.get("/api/settings")
def get_settings():
    return _read_config_py()


@app.post("/api/settings/save")
def save_settings(payload: Dict[str, Any] = Body(...)):
    # Merge with defaults to ensure all keys exist
    settings = DEFAULT_SETTINGS.copy()
    settings.update(payload or {})

    # Normalize REPORTS_DIR relative to config location if not absolute
    rep = settings.get("REPORTS_DIR")
    if rep:
        rep_path = Path(rep)
        if not rep_path.is_absolute():
            rep_path = (CONFIG_PATH.parent / rep_path).resolve()
        settings["REPORTS_DIR"] = str(rep_path)

    # Ensure project dir exists, then write config.py
    CONFIG_PATH.parent.mkdir(parents=True, exist_ok=True)
    CONFIG_PATH.write_text(_render_config_py(settings), encoding="utf-8")

    # Update the in‑process REPORTS_DIR so the UI reflects changes immediately
    global REPORTS_DIR
    try:
        REPORTS_DIR = Path(settings["REPORTS_DIR"]).resolve()
    except Exception:
        REPORTS_DIR = _get_reports_dir()

    return {"ok": True, "reports_dir": str(REPORTS_DIR)}


@app.post("/api/upload/id-map")
async def upload_id_map(file: UploadFile = File(...)):
    # Save uploaded CSV next to config.py and update config to reference it
    CONFIG_PATH.parent.mkdir(parents=True, exist_ok=True)
    dest = CONFIG_PATH.parent / "user_id_remap.csv"
    with dest.open("wb") as out:
        out.write(await file.read())

    # Patch config to point to this file
    cfg = _read_config_py()
    cfg["USER_ID_REMAP_PATH"] = str(dest)
    CONFIG_PATH.write_text(_render_config_py(cfg), encoding="utf-8")

    return {"ok": True, "path": str(dest)}

def _list_reports():
    if not REPORTS_DIR.exists():
        return []
    files = sorted(REPORTS_DIR.glob("run-*.json"), reverse=True)
    out = []
    for p in files:
        try:
            with p.open("r", encoding="utf-8") as f:
                data = json.load(f)
            out.append({
                "id": p.name,
                "started_at": data.get("started_at"),
                "ended_at": data.get("ended_at"),
                "duration_s": data.get("duration_s"),
                "events_read": data.get("counters", {}).get("events_read"),
                "events_kept": data.get("counters", {}).get("events_kept"),
                "events_sent": data.get("counters", {}).get("events_sent"),
                "mtu_estimate": data.get("mtu", {}).get("estimate"),
                "estimated_cost_usd": data.get("mtu", {}).get("estimated_cost_usd"),
                "dry_run": data.get("settings", {}).get("dry_run"),
            })
        except Exception:
            # Ignore malformed files, continue listing
            continue
    return out

# Define request model for running migrations
class RunRequest(BaseModel):
    dry_run: bool = True

# -------- Routes --------
@app.get("/api/migration/runs")
def list_runs():
    return {"runs": _list_reports()}

@app.get("/api/migration/runs/{report_id}")
def get_run(report_id: str):
    path = REPORTS_DIR / report_id
    if not path.exists():
        raise HTTPException(status_code=404, detail="Report not found")
    with path.open("r", encoding="utf-8") as f:
        data = json.load(f)
    return JSONResponse(data)

@app.get("/api/migration/run/{name}")
def get_run_by_name(name: str):
    path = REPORTS_DIR / name
    if not path.exists():
        raise HTTPException(status_code=404, detail="Report not found")
    with path.open("r", encoding="utf-8") as f:
        data = json.load(f)
    return JSONResponse(data)

@app.get("/api/migration/reports-dir")
def get_reports_dir():
    return {"reports_dir": str(REPORTS_DIR)}


# --- Migration runner endpoints ---
@app.post("/api/run")
def api_run(req: RunRequest):
    # Load settings from config.py managed by the UI
    settings = _read_config_py()
    settings["DRY_RUN"] = bool(req.dry_run)

    # Ensure reports dir exists (runner no longer creates it)
    reports_dir = Path(settings.get("REPORTS_DIR") or (DEFAULT_PROJECT_DIR / "migration_runs"))
    reports_dir.mkdir(parents=True, exist_ok=True)

    summary = run_migration(settings)
    return {"ok": True, "summary": summary}


@app.get("/api/run")
def api_run_get():
    # Convenience: GET triggers a dry run
    settings = _read_config_py()
    settings["DRY_RUN"] = True

    reports_dir = Path(settings.get("REPORTS_DIR") or (DEFAULT_PROJECT_DIR / "migration_runs"))
    reports_dir.mkdir(parents=True, exist_ok=True)

    summary = run_migration(settings)
    return {"ok": True, "summary": summary}


@app.options("/api/run")
def api_run_options():
    # Helpful if a preflight ever occurs
    return JSONResponse(
        content={},
        headers={
            "Access-Control-Allow-Origin": "*",
            "Access-Control-Allow-Methods": "POST, GET, OPTIONS",
            "Access-Control-Allow-Headers": "Content-Type",
        },
    )

# Mount static last so API routes take precedence
app.mount("/", StaticFiles(directory=STATIC_DIR, html=True), name="static")

# -------- Entrypoint used by CLI --------
def _find_open_port(host: str, preferred: int, tries: int = 20) -> int:
    """
    Return `preferred` if free, otherwise the next available port within `tries`.
    Raises RuntimeError if none found.
    """
    candidates = [preferred] + list(range(preferred + 1, preferred + tries + 1))
    for p in candidates:
        with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:
            s.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
            try:
                s.bind((host, p))
                return p  # it's free
            except OSError:
                continue
    raise RuntimeError(f"No free port found near {preferred}")

def start_ui(host: str = "127.0.0.1", port: int = 8000, reload: bool = False, auto_port: bool = True):
    """
    Launch the packaged UI. If auto_port=True and `port` is taken, it will try
    subsequent ports (8010, 8011, …) until it finds a free one.
    """
    chosen_port = port
    if auto_port:
        # Prefer a jump to 8010 first to avoid clashing with common 8000 backends
        base = 8010 if port == 8000 else port
        try:
            chosen_port = _find_open_port(host, base, tries=30)
        except RuntimeError:
            # final fallback: just try the originally requested port (may still raise)
            chosen_port = port

    print("━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━")
    print("Amplitude Migrator UI")
    if host == "0.0.0.0":
        print(f"▶ Local:    http://127.0.0.1:{chosen_port}")
        print(f"▶ Network:  http://{host}:{chosen_port}")
    else:
        print(f"▶ URL:      http://{host}:{chosen_port}")
    print("Reports dir:", REPORTS_DIR)
    print("━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━")

    uvicorn.run("amplitude_migrator.web.app:app", host=host, port=chosen_port, reload=reload)